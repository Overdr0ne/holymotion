;;; holymotion.el --- evil-easymotion, purified of evil

;; Author: Overdr0ne <scmorris.dev@gmail.com>
;; Keywords: convenience
;; Version: 20160228
;; Package-Requires: ((emacs "24") (avy "0.3.0") (cl-lib "0.5"))

;;; License:

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program. If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:
;; This code was shamelessly forked from https://github.com/PythonNut/evil-easymotion
;; which was itself a clone of the popular holymotion package for vim, which
;; describes itself in these terms:

;; > EasyMotion provides a much simpler way to use some motions in vim.
;; > It takes the <number> out of <number>w or <number>f{char} by
;; > highlighting all possible choices and allowing you to press one key
;; > to jump directly to the target.

;; If you're having trouble picturing this, please visit the github repo
;; for a screencast.

;; Usage/status
;; ============

;; A handful of motions are provided, prefixed with `holymotion`
;; It's easy to define your own holymotions:
;; (holymotion-make-motion
;;  holymotion-forward-to-word #'forward-to-word
;;  :scope 'line)
;;;; More advanced use-cases are detailed in README.md.

;;; Code:
(require 'cl-lib)
(require 'avy)

(defgroup holymotion nil
  "Emulate vim-easymotion."
  :group 'convenience
  :prefix "holymotion-")

(defcustom holymotion-keys nil
  "Value of `avy-keys' to set during motions.  Set to nil to leave unchanged."
  :type '(repeat :tag "Keys" character))

(defcustom holymotion-style nil
  "Value of `avy-style' to set during motions.  Set to nil to leave unchanged."
  :type '(choice
          (const :tag "Pre" pre)
          (const :tag "At" at)
          (const :tag "At Full" at-full)
          (const :tag "Post" post)
          (const :tag "De Bruijn" de-bruijn)
          (const :tag "Default" nil)))

(defvar holymotion-map (make-sparse-keymap)
  "Keymap used for the default bindings.")

(defun holymotion--jump (points)
  "Avy-jump to the set of POINTS generated by collector."
  (require 'avy)
  (let* ((avy-style (or holymotion-style avy-style))
         (avy-keys (or holymotion-keys avy-keys)))
    (avy-process points
                 (avy--style-fn avy-style))))

(defun holymotion--default-collect-postprocess (points)
  "Collect default postprocess using jump POINTS."
  (cl-stable-sort
   points
   #'<
   :key (lambda (pt)
          (if (equal (selected-window) (cdr pt))
              (abs (- (point) (car pt)))
            most-positive-fixnum))))

;;;###autoload
(defun holymotion--collect (func &optional
                                 scope
                                 all-windows
                                 initial-motion
                                 collect-postprocess
                                 include-invisible)
  "Repeatedly execute FUNC and collect the cursor positions into a list.

Optionally:

SCOPE: An object to limit the scope of an holymotion. `object` may be any *thing* understood by `thing-at-point`. In practice, `object` will often be `'line`.

ALL-WINDOWS to consider in search of candidates.

INITIAL-MOTION: When specified, `(goto-char (funcall callable))` is run before the motion is executed. For example, use this to jump to the BOL of each line as in holymotion with `:initial-position #'point-at-bol`. Unlike in `:pre-hook`, `callable` is run once per window when `:all-windows` is specified.

COLLECT-POSTPROCESS: When specified, `callable` is called on the collected list of points (which is of the form `((point window)...)`). Otherwise, the default function, which sorts the points in order of increasing distance from `(point)`, is used.

INCLUDE-INVISIBLE: When `expr` is non-`nil`, the motion will not skip over invisible overlays. This may be required for motions that generate dramatically different sets of points if they are started at different locations. This defaults to nil."
  (cl-letf ((points nil)
            (point nil)
            (avy-all-windows all-windows)
            ;; make sure the motion doesn't move the window
            (scroll-conservatively 101)
            (smooth-scrolling-mode nil)
            (scroll-margin 0))
    (if (functionp func)
        (avy-dowindows current-prefix-arg
          (save-excursion
            (save-restriction
              (when initial-motion
                (goto-char (funcall initial-motion)))
              (cl-destructuring-bind (beg . end)
                  (if scope
                      (bounds-of-thing-at-point scope)
                    (cons (point-min)
                          (point-max)))

                ;; trim trailing newline
                (when (= (char-before end) 10)
                  (cl-decf end))

                (narrow-to-region (max beg (window-start))
                                  (min end (window-end))))
              (while (and (ignore-errors
                            (setq this-command func
                                  last-command func)
                            (call-interactively func)
                            (unless include-invisible
                              (let ((ov (car (overlays-at (point)))))
                                (while (and ov (member
                                                'invisible
                                                (overlay-properties ov)))
                                  (goto-char (overlay-end ov))
                                  ;; This is a bit of a hack, since we
                                  ;; can't guarantee that we will end
                                  ;; up at the same point if we start
                                  ;; at the end of the invisible
                                  ;; region vs. looping through it.
                                  (call-interactively func)
                                  (setq ov (car (overlays-at (point)))))))
                            t)
                          (setq point (cons (point) (get-buffer-window)))
                          (not (member point points))
                          (push point points))))))
      (setq points (cl-remove-duplicates
                    (cl-mapcan (lambda (f)
                                 (holymotion--collect f scope all-windows))
                               func))))
    (funcall (or collect-postprocess
                 #'holymotion--default-collect-postprocess)
             points)))

(cl-defmacro holymotion-make-motion (name
                                     funcs
                                     &key
                                     pre-hook
                                     post-hook
                                     bind
                                     scope
                                     all-windows
                                     initial-motion
                                     collect-postprocess
                                     include-invisible)
  "Automatically define an holymotion for FUNCS, naming it NAME.

Keywords:

Add PRE-HOOK or POST-HOOK to further customize your motion command.

BIND: A list of forms to bind around the entire holymotion. `forms` may be any bindings accepted by `cl-letfâ€™.

SCOPE: An object to limit the scope of an holymotion. `object` may be any *thing* understood by `thing-at-point`. In practice, `object` will often be `'line`.

INITIAL-MOTION: When specified, `(goto-char (funcall callable))` is run before the motion is executed. For example, use this to jump to the BOL of each line as in holymotion with `:initial-position #'point-at-bol`. Unlike in `:pre-hook`, `callable` is run once per window when `:all-windows` is specified.

COLLECT-POSTPROCESS: When specified, `callable` is called on the collected list of points (which is of the form `((point window)...)`). Otherwise, the default function, which sorts the points in order of increasing distance from `(point)`, is used.

INCLUDE-INVISIBLE: When `expr` is non-`nil`, the motion will not skip over invisible overlays. This may be required for motions that generate dramatically different sets of points if they are started at different locations. This defaults to nil."
  `(defun ,name ()
     (interactive)
     (require 'avy)
     (avy-with ,name
       (cl-letf* ,bind
         ,(when pre-hook `(funcall ,(if (functionp pre-hook)
                                        pre-hook
                                      `(lambda () ,pre-hook))))
         (holymotion--jump (holymotion--collect ,funcs
                                                ,scope
                                                ,all-windows
                                                ,initial-motion
                                                ,collect-postprocess
                                                ,include-invisible))
         ,(when post-hook `(funcall ,(if (functionp post-hook)
                                         post-hook
                                       `(lambda () ,post-hook))))))))

(defmacro holymotion-derive-cmd (cmd)
  "Create and name a holymotion from CMD."
  `(progn
     (holymotion-make-motion ,(intern (concat "holymotion-" (symbol-name cmd)))
                             #',cmd
                             :scope 'line)))

;;;###autoload
(holymotion-make-motion
 holymotion-forward-to-word #'forward-to-word
 :scope 'line)

;;;###autoload
(holymotion-make-motion
 holymotion-forward-whitespace #'forward-whitespace
 :scope 'line)

;;;###autoload
(holymotion-make-motion
 holymotion-forward-word #'forward-word
 :scope 'line)

;;;###autoload
(holymotion-make-motion
 holymotion-backward-to-word #'backward-to-word
 :scope 'line)

;;;###autoload
(holymotion-make-motion
 holymotion-backward-word #'backward-word
 :scope 'line)

;;;###autoload
(holymotion-make-motion
 holymotion-next-line #'next-line
 :bind ((temporary-goal-column (current-column))
        (line-move-visual nil)))

;;;###autoload
(holymotion-make-motion
 holymotion-previous-line #'previous-line
 :bind ((temporary-goal-column (current-column))
        (line-move-visual nil)))

;;;###autoload
(holymotion-make-motion
 holymotion-next-visual-line #'next-line
 :bind ((temporary-goal-column (current-column))
        (line-move-visual t)))

;;;###autoload
(holymotion-make-motion
 holymotion-previous-visual-line #'previous-line
 :bind ((temporary-goal-column (current-column))
        (line-move-visual t)))

;;;###autoload
(holymotion-make-motion
 holymotion-backward-beginning-of-defun #'beginning-of-defun
 )

;;;###autoload
(holymotion-make-motion
 holymotion-backward-sentence #'backward-sentence)

;;;###autoload
(holymotion-make-motion
 holymotion-forward-sentence #'forward-sentence)

(provide 'holymotion)
;;; holymotion.el ends here
